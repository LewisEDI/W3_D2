Q1. Where are we instantiating instances of the Property class?

Answer: in the console file (property1 = Property.new, property2 = Property.new, Property3 = Property.new)

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

Answer: sql = "INSERT INTO properties
   (
     address,
     value,
     bedrooms,
     build
   )
   VALUES
   (
     $1,$2,$3,$4
   )
   RETURNING id"

Q3. In console.rb, which lines modify the database?

Answer: property1.delete()

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

Answer: Because it is defined for us by the DB and we could attempt to assign an id already in use.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?

Answer:  property.rb @id = options['id'].to_i if options['id']

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?

Answer: To make sure we are assigning the ID that has been generated

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Answer: Because they need to be applied to all the instances. Property.delete_all() for example.

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?

Answer1: An array

Answer2: @id = db.exec_prepared("save", values)[0]["id"].to_i

Q9. Why do we use prepared statements when performing database operations?

Answer: To prevent against SQL injection
